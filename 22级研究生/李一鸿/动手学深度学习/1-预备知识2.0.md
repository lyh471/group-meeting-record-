## 数据操作

### 入门

导入torch，虽然被称为pytorch，但导入的是torch

~~~py
import torch
~~~

下面是对torch一些基本的函数进行操作，为了加深印象并体会函数的用法，自己动手修改代码中的数值，并敲一遍代码运行一遍加深理解🤯

下面会频繁出现张量这个概念，可以形象理解为一个多元n维数组

#### torch.arange()

pytorch中arange()函数用法，其中有三个主要的参数，当然还有类型等参数用到再说，先说最基本的东西🐱

- **start** -- 初始值，默认为0，可选
- **step** -- 步长，默认为1，可选
- **end** -- 终值，必选

从默认值开始，产生一个1维度张量

返回的个数：⌈ (end-start)/step ⌉，（上取整，等于大于自己的最小整数）

~~~py
x = torch.arange(4)
x = [0, 1, 2, 3]
~~~

#### 张量的形状：

可以通过**reshape**函数改变张量的形状

~~~py
#将长度为4的行向量转换为形状2x2的矩阵
x = torch.arange(4)
[0, 1, 2, 3]
X = x.reshape(2, -1)
[[0, 1],
 [2, 3]]
~~~

==其中函数参数中的-1：不必手动确定形状，只要指定宽度或高度其中的一个值，剩下一个填写-1就可以调用自动计算维度的功能==。

如果张量的总数不满足重塑的形状会发生什么？增加0元素来满足形状吗？🤷‍♂️都不是，如果张量总数不满足重塑的新形状会报错！

<img src="C:\Users\lyh471\AppData\Roaming\Typora\typora-user-images\image-20220516102913982.png" alt="image-20220516102913982" style="zoom: 67%;" />

该函数只改变张量的形状，张量的大小不会改变。

张量大小即为元素的总数，可以用**numel**函数得到具体的返回值。

~~~
X.numel(),x.numel()
(4,4)
~~~

如果需要显示张量的形状，有**shape**属性可以显示张量==每个轴==的长度。

~~~py
x.shape
[4]
X.shape
[2, 2]
~~~

#### torch.zeros()

创建一个元素全为0的张量

zeros()有好多参数，目前学习只需要了解两个参数。

参数size和dtype

- **size** --  定义tensor的shape ，这里可以是一个list列表， 也可以是一个tuple元组
- **dtype** -- （可选）确定张量中元素的数据类型....哈哈都为0了，还要啥数据类型👻

~~~py
torch.zeros((1,2,3))
[[[0., 0., 0.],
  [0., 0., 0.]]]
~~~

#### torch.ones()

创建一个元素全为1的张量

参数同zeros()，这里使用列表的方法建立一个张量

~~~py
torch.ones([3, 2, 3])
[[[1., 1., 1.],
  [1., 1., 1.]],

  [[1., 1., 1.],
   [1., 1., 1.]],

   [[1., 1., 1.],
    [1., 1., 1.]]]
~~~

#### torch.randn()

torch.randn，用来生成随机数字的tensor，这些随机数字满足标准正态分布（0~1）
torch.randn(size)，size可以是一个整数，也可以是一个元组，输入的数值即为创建张量的形状

~~~py
torch.randn(3, 2, 1)
[[[-0.9017],
  [ 0.0043]],

 [[-1.2028],
  [-0.2177]],

 [[-1.3475],
  [ 0.4268]]]
~~~

### 运算符：

#### 标准运算：

==对于任意具有相同形状的张量，常见的标准运算符（+、-、*、/、**）都可以按对应位置元素进行计算==

下面只举两个不是很熟悉的运算符为例🐶

~~~py
#**是求幂运算
x = torch.tensor([3.0,4]) #3.0,说明x是浮点类型的一维张量
y = torch.tensor([2,2])
x ** y
[ 9., 16.] #[3^2, 4^2]
~~~

~~~py
#==是判等运算符，返回形状相同张量对应的元素是否相等的逻辑值
x = torch.tensor([3.0,2,4])
y = torch.tensor([3,1,4.0])
x == y
[ True, False,  True]
~~~

#### torch.exp()

指数运算，即返回值为e^x^，这里举一个典型值为例

~~~py
x = torch.tensor([0,1])
torch.exp(x)
tensor([1.0000, 2.7183]) #[e^0, e^1]
~~~

#### torch.cat()

张量的连接，将两个张量（tensor）拼接在一起，cat是concatenate的意思，即拼接，联系在一起。

用法即torch.cat((A,B),dim)，其中A、B即为将要连接的张量，dim是沿哪个轴进行拼接。

现以二维举例，其实有好多运算符，二维的很好理解但涉及高维，如三维、四维就有点无法想象运算之后的样子！😿对于现在的我来说确实没什么好方法，那就先理解低维（1，2维）张量。等日后熟练了可能就突然开窍了！

~~~py
x = torch.arange(2).reshape(2,-1)
[[0],
 [1]]
y = torch.arange(8).reshape(2,-1)
[[0, 1, 2, 3],
 [4, 5, 6, 7]]
torch.cat((x,y),dim=1)
[[0, 0, 1, 2, 3],
 [1, 4, 5, 6, 7]]
~~~

2x1的张量和2x4的张量，按列拼接得到了2x5的矩阵。

但是如果按行拼接会发生什么呢！？如果按行拼接的话，就是将两个张量堆叠起来，可是x张量只有1列，而y有4列，根本对不起来。所以它会利用==广播机制==吗？👮‍♂️

答案是不会，如果两个张量不能形成“规则”的张量它会报错.....

<img src="C:\Users\lyh471\AppData\Roaming\Typora\typora-user-images\image-20220517195054173.png" alt="image-20220517195054173" style="zoom:67%;" />

有弹幕好哥哥补充觉得很有道理🤤

dim = 0 添加记录

dim = 1 拼接特征

#### 广播机制：

在本节的标准运算中，运算的都是相同形状的张量，但是形状不同那些基本运算还能使用吗？

当然可以，可以调用广播机制扩充成相同的形状来继续执行按元素操作

广播机制使用最多的绝大多数都是沿轴的长度为1进行广播（以后具体可能很有用，现在并没有感觉多有用）

下面举个例子

~~~py
a = torch.arange(2).reshape(1,-1)
[[0, 1]]
b = torch.arange(2).reshape(-1,1)
[[0],
 [1]]
~~~

对a，b进行运算，首先将a(1x2)，b(2x1)使用广播机制转换成相同的形状

a复制行，b复制列，转换为2x2形状的张量进行运算

~~~py
a = [[0, 1],[0, 1]]
b = [[0, 0],[1, 1]]
~~~

~~~c
a+b, a-b, a*b
[[0, 1],
 [1, 2]]

[[0, 1],
 [-1, 0]]

[[0, 0],
 [0, 1]]
~~~

这个机制的存在，可能在标量相加时结果会出现问题，其原因可能形状不同而产生广播机制造成

==a, b虽然形状不匹配，但它的维度一样，所以只有维度一样才能利用广播机制进行运算==

⚠️另外，假设一个2x3的张量和一个3x2的张量能进行广播机制转换成6x6（扩充到2，3的公倍数）进行计算吗？

答案是并不能....会报错

<img src="C:\Users\lyh471\AppData\Roaming\Typora\typora-user-images\image-20220517205005149.png" alt="image-20220517205005149" style="zoom:67%;" />

💀原因现在的我也不是很清楚，可能是规定？确实不能无缘无故的增加矩阵....没有啥道理，或许如果是倍数就可以了

在举一个例子，4x4和2x2进行运算，现在4直接是2的倍数那是不是会变成4x4呢？

💀也不行，==可能必须是轴的长度为1才能进行广播吧==

*这个问题暂时先搁置在这儿吧，等以后深度了解使用广播机制就能明白了*

#### 索引和切片：

张量中的元素可以通过索引访问

与任何python数组一样，==第一个元素索引为0，最后一个元素索引是-1==

~~~py
#访问元素
[1,2]: 第一行，第二列所指向的元素
[1,:]: 第一行的所有元素
[:,1]: 第一列的所有元素
[1:3,1:]: 第一行到第二行（1:3左闭右开，1~2），第一列之后所有的列（是一个子区域）
[::3,::2]: 每三行一条，每两列一跳所指的元素
~~~

举个不常见的例子：

~~~py
x = [[ 0,  1,  2,  3],
 	 [ 4,  5,  6,  7],
 	 [ 8,  9, 10, 11],
 	 [12, 13, 14, 15]]

x[::4,::4]

[[ 0,  3],
 [12, 15]]
~~~

除读取外，还可以通过指定索引来将元素写入矩阵，还是以刚刚上面的张量x为例😼

~~~py
x[1:3,1:] = -1
[[ 0,  1,  2,  3],
 [ 4, -1, -1, -1],
 [ 8, -1, -1, -1],
 [12, 13, 14, 15]]
#在第一行到第二行下，第一列之后所有的列元素被赋值为-1
~~~

#### 节省内存：

运行操作可能会导致新结果分配内存，比如将两个张量A、B相加，在赋值给A，此时内存会为“A”分配一个新的地址，可能说的不太明白，那就把课本上的证明搬上来在叙述一遍😸

~~~py
before = id(A) #id()类似于C的指针，能指向A在内存的地址
A = A+B
id(A) == before #分配后的内存地址和之前进行判等

False #结果答案是不等，说明又给A重新分配了新的内存
~~~

这样不太好，一是如果运行的变量达到几百兆，如果这样写的话每次都要分配新的内存，其次代码其他部分在访问变量时可能还会指向旧的内存所在位置，而出现错误

鉴于以上两种原因，原地执行（不分配新的内存）是很有必要的，这样不仅能节省内存还能避免可能出现的引用错误，下面介绍原地执行的方法

~~~py
C[:] = A+B
#创建一个与A形状相同的张量，使用切片的方法将操作结果分配给一个新的张量
#这里C的内存地址创建和赋值后不会改变
~~~

当然如果后续用不到A原先值进行计算，也可以

~~~py
A[:] = A+B
A += A+B
~~~

#### 转换为其他python对象：

将Pytorch中的张量（tensor）转换为NumPy的数组（ndarray）。张量和数组底层逻辑是一样的所以很好转换

~~~py
A = X.numpy()
B = torch.tensor(A)
type(A), type(B)

(numpy.ndarray, torch.Tensor)
~~~

将一维单元张量转换为Python标量，可以调用item函数或Python的内置函数

~~~py
a = torch.tensor([6.48])
a,a.item(),float(a),int(a)

tensor([6.4800]), 6.480000019073486, 6.480000019073486, 6
~~~

❓怎么转换为float，6.48后面还有那么多小数呀？？？可能涉及数字的存储吧，大概，有点让人摸不到头脑

要说pytorch和numpy的区别，我觉得这两个很像，但还是有点区别的。tensor张量是数学上的概念，array数组是计算机上的概念，多元数组是计算机上的操作，没有数学上的定义。张量虽有数学上的概念但在深度学习中可以当作多元数组来使用。

MXNet用的就是Numpy，将来肯定还会打交道的，但是万变不离其宗😹



## 数据预处理

深度学习是干啥的？解决现实问题！但是现实问题的数据一般都不会给你一个张量对张量进行操作，所以需要自己将数据处理成深度学习能够处理的数据。这个过程叫做数据预处理

在python中常用的数据分析工具中，使用pandas软件包进行数据分析，在这一节的学习中只是数据预处理的入门，之后还会接触更多的预处理技术

所以在这节中只使用它提供的代码

这一节最重要的目的不是自己动手实现，而是弄明白这个过程。

### 读取数据集：

#### pandas

Pandas 是 Python 中的数据操纵和分析软件包，也是一个强大的数据分析库

- 允许为行和列设定标签
- 轻松地处理 NaN 值
- 可以将不同的数据集合并到一起
- 能够将不同格式的数据加载到 DataFrame 中

当然还有其他功能，先简单的了解一下这是个什么东西😸

#### csv文件：

可以理解为一个表格文件，是个电子表格

此文件，一行即为数据表的一行。生成数据表字段用半角逗号隔开，可以利用excel直接打开

就是个电子表

#### os:

os是operation system（操作系统）的缩写，这个库就是对操作系统的封装。os模块提供了多数操作系统的功能接口函数。

可以利用os在指定路径创建文件

~~~py
import os

os.makedirs(os.path.join('..', 'data'), exist_ok=True)
data_file = os.path.join('..', 'data', 'house_tiny.csv') #这里的data_file是路径字符串
~~~

##### os.path.join()

拼接路径的时候用的。在windows系统下，第一个路径会拼接成	..\data

它会根据系统而选用 ' \ '或 ' / '分隔符拼接路径

第二个路径会拼接成 ..\data\house_tiny.csv

哦，也不知道是哪个好哥哥提醒，说⚠️**python地址的输入不能直接用“\”**，否则会报错，所以采用这个函数，如果非要用的话好像要双反斜杠

##### os.makedirs()

用于递归创建目录，什么叫递归创建目录？😿不知道，现在也不想知道，就不去展开了解啦

有几个参数

- **path** -- 需要递归创建的目录，可以是相对或者绝对路径。必须存在
- **mode** -- 权限模式，现在没有用到，可选
- **exist_ok** -- 只有在目录不存在时创建目录，目录已存在时不会抛出异常。==默认是false，所以创建目录时可以令它为true，这样目录已存在也不会抛出异常==

好像可能还有parents跟父目录有关的参数，以后再说吧

这个文件应该d2l这个包中自带了，不需要自己创建

#### 写入数据样本：

~~~py
with open(data_file, 'w') as f: #将对文件这个写入操作改名为f方便操作
    f.write('NumRooms,Alley,Price\n')  # 列名
    f.write('NA,Pave,127500\n')  # 每行表示一个数据样本
    f.write('2,NA,106000\n')
    f.write('4,NA,178100\n')
    f.write('NA,NA,140000\n'
~~~

#### 导出数据集：

导出数据集可以利用pandas包中的read_csv函数

##### pandas.read_csv()

调用pd中的read_csv读取csv文件并将数据返回

一个很常用的参数

- **filepath_or_buffer** -- 文件的路径，可以是URL，也可以是实现read方法的任意对象

当然还有其他参数，这里就说一下最常用的，以后遇到以后再说😸

==它返回的是一个表格型的数据结构，有行索引和列索引==

~~~py
import pandas as pd #导入pandas包，也叫做pd

data = pd.read_csv(data_file) #调用pd中的read_csv读取csv文件并将数据返回给data
print(data) #显示daya

 	NumRooms 	Alley   Price
0     NaN  	    Pave  	127500
1     2.0   	NaN  	106000
2     4.0   	NaN  	178100
3     NaN   	NaN  	140000
~~~

### 处理缺失值：

机器学习就是用来处理缺失数据的——预测未来

表中的“NaN”代表缺失值，转换成能够处理的张量，缺失值怎要转换能代表实际意义的数据呢

一般有两个方法，插入法和删除法

删除法非常简单，直接忽略缺失值即可，所以了解一下插入法😸

⚠️这里的缺失值NaN不是表中的数据，是在读表时数据不存在才以NaN替代

表中只有Price这一列没有缺失，所以先将有缺失和未缺失的列分离开，这里使用pandas中的**iloc**位置索引分开

~~~py
inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]
#将所有行的，0列（NumRooms）和 1列（Alley）数据放在inputs中（含有缺失值的列
#将最后一列（Price）拿出来放在outputs中
~~~

对inputs中缺少的值，用同一列均值替换“NaN”项

~~~py
inputs = inputs.fillna(inputs.mean()) #mean求平均值，fillna对NA所有域填一个该类型下的均值
print(inputs)

 	NumRooms 	Alley  
0     3.0  	    Pave  	
1     2.0   	NaN  	
2     4.0   	NaN  	
3     3.0   	NaN  	
~~~

可以看到，数值型的缺省值已经补充完了，但是在Alley一列中，数据类型并不是数值型，这里做一步转换。

可以理解Alley有两个类型，Pave类和NaN类

利用pandas将此列自动转换为“Alley_Pave”和“Alley_nan”。

巷子类型为“Pave”的行会将“Alley_Pave”的值设置为1，“Alley_nan”的值设置为0

 缺少巷子类型的行会将“Alley_Pave”和“Alley_nan”分别设置为0和1🤫

#### pandas.get_dummies()

 在对变量进行独热编码时使用，❓什么是独热编码

One-Hot 编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效

分类变量作为二进制项来表示，比如季节有春夏秋冬四个属性，将季节进行展开，即二进制0010可以表示秋季

- **data** -- array-like, Series, or DataFrame 输入的数据
- **dummy_na ** --  bool, default False 增加一列表示空缺值，如果False就忽略空缺值

~~~py
inputs = pd.get_dummies(inputs, dummy_na=True)
print(inputs)

 	NumRooms  Alley_Pave  Alley_nan
0     3.0        1          0
1     2.0        0          1
2     4.0        0          1
3     3.0        0          1
~~~

### 转换为张量格式：

处理缺失值后，现在inputs和outputs所有条目都是数值类型了，这样就可以把它转换为张量格式

~~~py
import torch

x = torch.tensor(inputs.values)
y = torch.tensor(outputs.values)
x, y

x = [[3., 1., 0.],
     [2., 0., 1.],
     [4., 0., 1.],
     [3., 0., 1.]]
y = [127500, 106000, 178100, 140000]
~~~

❓有个地方不明白，我知道inputs、outputs是read_csv()函数返回的表格类型数据，那么在python中这个数据类型有没有具体的名字？有没有具体的属性？看样子是有的，这不有xxxx.values了，之前还用了xxxx.iloc[]

*但查了好久也没找到这个数据类型具体的名字是什么，有什么具体的用法，只能以后再说了。*😿
